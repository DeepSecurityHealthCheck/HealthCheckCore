#Pyhon imports
import os
import pprint
import logging

#Deep Security imports
from deepsecurity import AntiMalwareConfiguration
from deepsecurity import ScheduledTasks
from deepsecurity import ScheduledTask

#lib imports
from .yaml_parser import YAMLParser
from tqdm import tqdm


#Check Utils imports
from .check_utils import CheckItem as CheckItem
from .check_utils import Operator as op
from .check_utils import run_checklist as run_checklist

"""
 This module contains all necessary methods to check for best practices
conformity of the anti-malware module and other configurations.

This moudle **Should not interact with the API directly** but rather recieve
input which is returned by SDK calls.
"""

class AntiMalwareCheckResults(object):
    """Used to store the types of checklist results a am config may have"""
    def __init__(self, real_time = None, scheduled = None, manual = None):
        super(AntiMalwareCheckResults, self).__init__()
        self.real_time = real_time
        self.scheduled = scheduled
        self.manual = manual

    def __repr__(self):
        if self.real_time != None:
            #return("AM CheckResult\n\tRT:"+str(self.real_time))
            return(pprint.pformat( str(self.real_time) ))
        else:
            #return("AM CheckResult\n\tSCH:"+str(self.scheduled)+"\n\tMAN:"+str(self.manual))
            return( pprint.pformat( [str(self.scheduled), str(self.manual)] ))



class AntiMalwareChecker(object):
    def __init__(self, dir_path, parser):
        file_path = os.path.join(dir_path,"anti_malware_configuration.yml")

        self.real_time_scan_checklist = parser.load_module(file_path,"real_time_scan")['items']
        self.scheduled_scan_checklist = parser.load_module(file_path,"scheduled_scan")['items']
        self.manual_scan_checklist = parser.load_module(file_path,"manual_scan")['items']

    def check_anti_malware_configurations(self, config_list):

        """
        Checks if each AntiMalwareConfiguration object in the list is in accordance
        with best practices

        Args:
            config_list: AntiMalwareConfiguration list to check

        Returns:
            dict of type: {AntiMalwareConfiguration.id:AntiMalwareCheckResults}
        """
        config_dict = {}
        config_fixes = {
            'scan_action_for_virus'  : {'real-time': 'clean', 'on-demand': 'clean'},
            'scan_action_for_trojans': {'real-time': 'delete', 'on-demand': 'delete'},
            'scan_action_for_packer' : {'real-time': 'quarantine', 'on-demand': 'quarantine'},
            'scan_action_for_cookies': {'real-time': 'delete', 'on-demand': 'delete'},
            'scan_action_for_other_threats': {'real-time': 'quarantine', 'on-demand': 'quarantine'},
            'scan_action_for_possible_malware': {'real-time': 'active-action', 'on-demand': 'quarantine'}
        }

        with tqdm(total=len(config_list), ascii=True, desc="Checking AM Configs") as pbar:
            for config in config_list:

                for config_name, fix in config_fixes.items():
                    if getattr(config,config_name) is None:
                        setattr(config, config_name, fix[config.scan_type])

                pbar.update(1)
                result = AntiMalwareCheckResults()

                if config.scan_type == "real-time":
                    result.real_time = run_checklist(config, self.real_time_scan_checklist, return_failures=True, logger=logging.getLogger())
                else:
                    result.manual = run_checklist(config, self.manual_scan_checklist, return_failures=True, logger=logging.getLogger())
                    result.scheduled = run_checklist(config, self.scheduled_scan_checklist, return_failures=True,logger=logging.getLogger())

                config_dict[config.id] = result

        return config_dict
